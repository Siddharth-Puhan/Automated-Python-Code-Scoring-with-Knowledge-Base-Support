[
  {
    "category": "Sort Algorithms",
    "topic": "Bubble Sort",
    "description": "Sorts a list by repeatedly swapping adjacent elements if they are in the wrong order.",
    "optimal_code": {
      "iterative": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]"
    },
    "complexity": {
      "time": "O(n^2)",
      "space": "O(1)"
    },
    "metrics": {
      "cyclomatic_complexity": 3,
      "lines_of_code": 5
    },
    "tags": ["bubble sort", "comparison sort", "iterative", "simple"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Merge Sort",
    "description": "A divide-and-conquer algorithm that splits the list into halves, sorts them, and merges the sorted halves.",
    "optimal_code": {
      "recursive": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr)//2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1; k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1; k += 1"
    },
    "complexity": {
      "time": "O(n log n)",
      "space": "O(n)"
    },
    "metrics": {
      "cyclomatic_complexity": 6,
      "lines_of_code": 15
    },
    "tags": ["merge sort", "divide and conquer", "recursion", "stable"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Quick Sort",
    "description": "Sorts an array by partitioning it around a pivot element and recursively sorting the subarrays.",
    "optimal_code": {
      "recursive": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr)//2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)"
    },
    "complexity": {
      "time": "O(n log n) average / O(n^2) worst-case",
      "space": "O(log n)"
    },
    "metrics": {
      "cyclomatic_complexity": 4,
      "lines_of_code": 7
    },
    "tags": ["quick sort", "divide and conquer", "recursion", "pivot"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Selection Sort",
    "description": "Sorts a list by repeatedly finding the minimum element from the unsorted part and placing it at the beginning.",
    "optimal_code": {
      "iterative": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]"
    },
    "complexity": {
      "time": "O(n^2)",
      "space": "O(1)"
    },
    "metrics": {
      "cyclomatic_complexity": 3,
      "lines_of_code": 6
    },
    "tags": ["selection sort", "iterative", "comparison sort"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Heap Sort",
    "description": "Converts the list into a heap and repeatedly extracts the maximum element to build a sorted array.",
    "optimal_code": {
      "iterative": "def heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)"
    },
    "complexity": {
      "time": "O(n log n)",
      "space": "O(1)"
    },
    "metrics": {
      "cyclomatic_complexity": 6,
      "lines_of_code": 15
    },
    "tags": ["heap sort", "heap", "comparison sort"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Insertion Sort",
    "description": "Builds the final sorted list one element at a time by inserting each element into its correct position.",
    "optimal_code": {
      "iterative": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key"
    },
    "complexity": {
      "time": "O(n^2)",
      "space": "O(1)"
    },
    "metrics": {
      "cyclomatic_complexity": 3,
      "lines_of_code": 6
    },
    "tags": ["insertion sort", "comparison sort", "iterative"]
  },
  {
    "category": "Sort Algorithms",
    "topic": "Count Sort",
    "description": "Sorts integers by counting the occurrences of each unique value and placing them in the correct order.",
    "optimal_code": {
      "iterative": "def count_sort(arr):\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    sorted_arr = []\n    for i in range(len(count)):\n        sorted_arr.extend([i] * count[i])\n    return sorted_arr"
    },
    "complexity": {
      "time": "O(n + k)",
      "space": "O(k)"
    },
    "metrics": {
      "cyclomatic_complexity": 3,
      "lines_of_code": 8
    },
    "tags": ["count sort", "non-comparison", "integer sort"]
  }
]
